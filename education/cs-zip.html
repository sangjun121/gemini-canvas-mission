<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS.zip - 백엔드 전공지식 퀴즈</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
        
        body {
            font-family: 'Pretendard', sans-serif;
            background-color: #f3f4f6;
        }

        .fade-in {
            animation: fadeIn 0.4s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .option-btn {
            transition: all 0.2s;
        }
        
        .option-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .typing-effect {
            border-right: 2px solid #3b82f6;
            white-space: pre-wrap;
            overflow: hidden;
            animation: blink 0.75s step-end infinite;
        }

        @keyframes blink {
            from, to { border-color: transparent }
            50% { border-color: #3b82f6; }
        }

        /* Hide scrollbar for clean UI */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1; 
        }
        ::-webkit-scrollbar-thumb {
            background: #c1c1c1; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8; 
        }
    </style>
</head>
<body class="text-gray-800 antialiased min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-white shadow-sm sticky top-0 z-10">
        <div class="max-w-4xl mx-auto px-4 py-4 flex justify-between items-center">
            <h1 class="text-xl font-bold text-blue-600 flex items-center gap-2 cursor-pointer" onclick="app.navigate('home')">
                <i class="fas fa-file-zipper"></i> CS.zip
            </h1>
            <nav class="flex gap-4">
                <button onclick="app.navigate('home')" class="text-gray-600 hover:text-blue-600 font-medium transition-colors">홈</button>
                <button onclick="app.navigate('archive')" class="text-gray-600 hover:text-blue-600 font-medium transition-colors">
                    <i class="fas fa-book-bookmark"></i> 내 아카이브
                </button>
            </nav>
        </div>
    </header>

    <!-- Main Content Area -->
    <main class="flex-grow max-w-4xl mx-auto w-full px-4 py-8">
        
        <!-- Screen 1: Home (Category Selection) -->
        <div id="screen-home" class="fade-in hidden">
            <div class="text-center mb-10">
                <h2 class="text-3xl font-bold mb-4 text-gray-900"><span class="text-blue-600">CS.zip</span> 백엔드 모의고사</h2>
                <p class="text-gray-600">취업 준비와 전공 지식 복습을 위한 맞춤형 퀴즈 플랫폼입니다.<br>원하는 카테고리를 선택하고 무작위 10문제를 풀어보세요!</p>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <button onclick="app.openQuizSettings('종합')" class="bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-xl p-6 shadow-md hover:shadow-lg transform hover:-translate-y-1 transition-all text-left group">
                    <h3 class="text-xl font-bold mb-2 flex justify-between items-center">
                        종합 모의고사 <i class="fas fa-arrow-right opacity-0 group-hover:opacity-100 transition-opacity"></i>
                    </h3>
                    <p class="text-blue-100 text-sm">전체 과목에서 무작위로 문제가 출제됩니다.</p>
                </button>
                <button onclick="app.openQuizSettings('네트워크')" class="bg-white border border-gray-200 rounded-xl p-6 shadow-sm hover:shadow-md transform hover:-translate-y-1 transition-all text-left group">
                    <h3 class="text-xl font-bold mb-2 text-gray-800 flex justify-between items-center">
                        네트워크 <i class="fas fa-arrow-right text-gray-400 opacity-0 group-hover:opacity-100 transition-opacity"></i>
                    </h3>
                    <p class="text-gray-500 text-sm">TCP/IP, OSI 7계층, HTTP 등 네트워크 통신 기반 지식</p>
                </button>
                <button onclick="app.openQuizSettings('운영체제')" class="bg-white border border-gray-200 rounded-xl p-6 shadow-sm hover:shadow-md transform hover:-translate-y-1 transition-all text-left group">
                    <h3 class="text-xl font-bold mb-2 text-gray-800 flex justify-between items-center">
                        운영체제 <i class="fas fa-arrow-right text-gray-400 opacity-0 group-hover:opacity-100 transition-opacity"></i>
                    </h3>
                    <p class="text-gray-500 text-sm">프로세스/스레드, 메모리 관리, 데드락 등 OS 핵심 지식</p>
                </button>
                <button onclick="app.openQuizSettings('데이터베이스')" class="bg-white border border-gray-200 rounded-xl p-6 shadow-sm hover:shadow-md transform hover:-translate-y-1 transition-all text-left group">
                    <h3 class="text-xl font-bold mb-2 text-gray-800 flex justify-between items-center">
                        데이터베이스 <i class="fas fa-arrow-right text-gray-400 opacity-0 group-hover:opacity-100 transition-opacity"></i>
                    </h3>
                    <p class="text-gray-500 text-sm">트랜잭션, 인덱싱, 정규화 등 DB 설계 및 관리 지식</p>
                </button>
                <button onclick="app.openQuizSettings('자료구조')" class="bg-white border border-gray-200 rounded-xl p-6 shadow-sm hover:shadow-md transform hover:-translate-y-1 transition-all text-left group">
                    <h3 class="text-xl font-bold mb-2 text-gray-800 flex justify-between items-center">
                        자료구조 <i class="fas fa-arrow-right text-gray-400 opacity-0 group-hover:opacity-100 transition-opacity"></i>
                    </h3>
                    <p class="text-gray-500 text-sm">배열, 리스트, 트리, 해시 등 데이터를 다루는 핵심 구조</p>
                </button>
            </div>
        </div>

        <!-- Quiz Settings Modal -->
        <div id="quiz-settings-modal" class="fixed inset-0 bg-black/50 hidden flex items-center justify-center z-50 fade-in">
            <div class="bg-white rounded-xl shadow-xl w-11/12 max-w-md p-6">
                <div class="flex justify-between items-center mb-5">
                    <h3 class="text-xl font-bold text-gray-900" id="modal-category-title">카테고리 설정</h3>
                    <button onclick="app.closeQuizSettings()" class="text-gray-400 hover:text-gray-600 transition-colors"><i class="fas fa-times text-lg"></i></button>
                </div>
                
                <div class="space-y-5 mb-8">
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">난이도 선택</label>
                        <select id="setting-difficulty" class="w-full border border-gray-300 rounded-lg p-3 outline-none focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all text-gray-700">
                            <option value="전체">전체 (랜덤)</option>
                            <option value="초급">초급 (기초 개념)</option>
                            <option value="중급">중급 (응용 및 동작 원리)</option>
                            <option value="고급">고급 (심화 및 문제 해결)</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">문제 개수</label>
                        <select id="setting-count" class="w-full border border-gray-300 rounded-lg p-3 outline-none focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all text-gray-700">
                            <option value="5">5문제 (가볍게 풀기)</option>
                            <option value="10" selected>10문제 (표준)</option>
                            <option value="15">15문제 (집중 훈련)</option>
                            <option value="20">20문제 (실전 모의고사)</option>
                        </select>
                    </div>
                </div>
                
                <div class="flex gap-3">
                    <button onclick="app.closeQuizSettings()" class="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold py-3 rounded-lg transition-colors">취소</button>
                    <button onclick="app.applySettingsAndStart()" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg shadow-md transition-colors">퀴즈 시작</button>
                </div>
            </div>
        </div>

        <!-- Screen 2: Quiz -->
        <div id="screen-quiz" class="fade-in hidden">
            <div class="bg-white rounded-xl shadow-md p-6 md:p-8 relative">
                <!-- Progress Bar -->
                <div class="mb-6">
                    <div class="flex justify-between items-center text-sm text-gray-500 mb-2">
                        <div>
                            <span id="quiz-category-badge" class="bg-blue-100 text-blue-800 px-2 py-1 rounded font-medium text-xs mr-1">카테고리</span>
                            <span id="quiz-difficulty-badge" class="bg-purple-100 text-purple-800 px-2 py-1 rounded font-medium text-xs hidden">난이도</span>
                        </div>
                        <span id="quiz-progress-text" class="font-medium">문제 1 / 10</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="quiz-progress-bar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style="width: 10%"></div>
                    </div>
                </div>

                <!-- Question -->
                <div class="mb-8 min-h-[100px]">
                    <h2 id="quiz-question" class="text-xl md:text-2xl font-bold text-gray-800 leading-snug">질문이 여기에 표시됩니다.</h2>
                </div>

                <!-- Options -->
                <div id="quiz-options" class="grid grid-cols-1 gap-3 mb-8">
                    <!-- Options injected via JS -->
                </div>

                <!-- Explanation Box (Hidden by default) -->
                <div id="quiz-explanation" class="hidden mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg text-sm text-gray-700 fade-in">
                    <p class="font-bold text-blue-800 mb-1"><i class="fas fa-lightbulb text-yellow-500 mr-1"></i> 해설</p>
                    <p id="quiz-explanation-text"></p>
                </div>

                <!-- Action -->
                <div class="flex justify-end">
                    <button id="btn-next-question" onclick="app.nextQuestion()" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg font-bold shadow-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed hidden">
                        다음 문제 <i class="fas fa-chevron-right ml-1"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Screen 3: Results -->
        <div id="screen-result" class="fade-in hidden">
            <div class="bg-white rounded-xl shadow-md p-6 md:p-8 mb-6 text-center">
                <h2 class="text-3xl font-bold text-gray-800 mb-2">퀴즈 결과</h2>
                <div class="text-6xl font-extrabold text-blue-600 mb-4" id="result-score">80점</div>
                <p id="result-msg" class="text-gray-600 mb-6">훌륭합니다! 기본기가 탄탄하시네요.</p>
                <div class="flex justify-center gap-4">
                    <button onclick="app.navigate('home')" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-6 py-2 rounded-lg font-medium transition-colors">
                        홈으로
                    </button>
                    <button onclick="app.navigate('archive')" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg font-medium shadow-md transition-colors">
                        아카이브 확인하기
                    </button>
                </div>
            </div>

            <h3 class="text-xl font-bold text-gray-800 mb-4 px-2">문제 풀이 및 복습 노트</h3>
            <div id="result-list" class="flex flex-col gap-4">
                <!-- Review Items injected via JS -->
            </div>
        </div>

        <!-- Screen 4: Archive -->
        <div id="screen-archive" class="fade-in hidden">
            <div class="flex justify-between items-end mb-6">
                <div>
                    <h2 class="text-2xl font-bold text-gray-900">내 아카이브</h2>
                    <p class="text-gray-500 text-sm mt-1">내가 틀렸거나 저장한 문제들을 모아보고 약점을 보완하세요.</p>
                </div>
                <button onclick="app.runAIAnalysis()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg font-medium shadow-sm transition-colors flex items-center gap-2">
                    <i class="fas fa-robot text-indigo-200"></i> AI 약점 분석
                </button>
            </div>

            <!-- AI Analysis Result Panel (Hidden by default) -->
            <div id="ai-analysis-panel" class="bg-gradient-to-br from-indigo-50 to-blue-50 border border-indigo-100 rounded-xl p-6 mb-8 hidden shadow-inner">
                <div class="flex items-center gap-2 mb-4">
                    <i class="fas fa-sparkles text-indigo-500"></i>
                    <h3 class="text-lg font-bold text-indigo-900">AI 약점 분석 및 처방</h3>
                </div>
                <div id="ai-analysis-content" class="text-gray-700 leading-relaxed mb-6 min-h-[60px] typing-effect">
                    분석 중입니다...
                </div>
                
                <div id="ai-recommendations" class="hidden">
                    <h4 class="font-bold text-gray-800 mb-3 text-sm flex items-center gap-2">
                        <i class="fas fa-bullseye text-red-500"></i> 연관 추천 문제 (복습용)
                    </h4>
                    <div id="ai-recommended-questions" class="flex flex-col gap-3">
                        <!-- Recommended questions injected via JS -->
                    </div>
                </div>
            </div>

            <!-- Saved Questions List -->
            <div id="archive-list" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Archive Items injected via JS -->
            </div>
            
            <div id="archive-empty" class="text-center py-16 hidden">
                <i class="fas fa-folder-open text-gray-300 text-5xl mb-4"></i>
                <p class="text-gray-500">아직 아카이브에 저장된 문제가 없습니다.<br>퀴즈를 풀고 틀린 문제를 저장해보세요!</p>
            </div>
        </div>

    </main>

    <script>
        // --- 1. MOCK DATABASE (CS Questions) ---
        // 카테고리별 10문제씩 총 40문제 제공 (데이터베이스, 운영체제, 네트워크, 자료구조)
        const questionsDB = [
            // [네트워크]
            { id: 1, cat: '네트워크', concept: 'TCP/IP', level: '중급', q: 'TCP 3-way handshake에서 클라이언트가 서버에 연결을 요청할 때 최초로 보내는 플래그(Flag)는 무엇인가요?', options: ['SYN', 'ACK', 'FIN', 'RST'], a: 0, exp: '연결을 시작할 때 클라이언트는 동기화(Synchronize)를 의미하는 SYN 패킷을 보냅니다.' },
            { id: 2, cat: '네트워크', concept: 'OSI 7계층', level: '초급', q: 'OSI 7계층 중 물리적인 통신 링크를 통해 신뢰성 있는 데이터 전송을 보장하며, MAC 주소를 사용하는 계층은?', options: ['네트워크 계층', '데이터 링크 계층', '전송 계층', '물리 계층'], a: 1, exp: '데이터 링크 계층(2계층)은 노드 간의 신뢰성 있는 데이터 전송을 담당하며 MAC 주소를 사용합니다.' },
            { id: 3, cat: '네트워크', concept: 'HTTP', level: '초급', q: 'REST API 설계 시 자원의 생성을 의미하는 HTTP 메서드로 가장 적절한 것은?', options: ['GET', 'POST', 'PUT', 'DELETE'], a: 1, exp: 'POST 메서드는 새로운 리소스를 생성(Create)할 때 사용됩니다.' },
            { id: 4, cat: '네트워크', concept: 'DNS', level: '초급', q: '도메인 이름을 IP 주소로 변환해주는 시스템은 무엇인가요?', options: ['DHCP', 'NAT', 'DNS', 'ARP'], a: 2, exp: 'DNS(Domain Name System)는 사람이 읽을 수 있는 도메인 이름을 머신이 읽을 수 있는 IP 주소로 변환합니다.' },
            { id: 5, cat: '네트워크', concept: 'TCP/UDP', level: '초급', q: 'UDP(User Datagram Protocol)의 특징으로 알맞지 않은 것은?', options: ['비연결형 서비스이다.', '신뢰성 있는 데이터 전송을 보장한다.', 'TCP보다 전송 속도가 빠르다.', '헤더의 크기가 작다.'], a: 1, exp: 'UDP는 신뢰성 있는 전송을 보장하지 않습니다. 신뢰성 보장은 TCP의 특징입니다.' },
            { id: 6, cat: '네트워크', concept: 'HTTP', level: '중급', q: 'HTTP 상태 코드 중 "클라이언트가 권한이 없어 요청이 거부됨"을 의미하는 코드는?', options: ['400 Bad Request', '401 Unauthorized', '403 Forbidden', '404 Not Found'], a: 2, exp: '401은 인증(Authentication) 실패, 403 Forbidden은 인가(Authorization/권한) 부족을 의미합니다.' },
            { id: 7, cat: '네트워크', concept: '웹 보안', level: '고급', q: '브라우저에서 다른 출처(Origin)의 리소스를 공유할 수 있도록 설정하는 정책은?', options: ['CORS', 'XSS', 'CSRF', 'SOP'], a: 0, exp: 'CORS(Cross-Origin Resource Sharing)는 교차 출처 리소스 공유를 허용하는 정책입니다.' },
            { id: 8, cat: '네트워크', concept: 'HTTPS', level: '고급', q: 'HTTPS 통신에서 대칭키를 안전하게 교환하기 위해 사용하는 암호화 방식은?', options: ['비대칭키(공개키) 암호화', '해시 함수', '블록 암호화', '스트림 암호화'], a: 0, exp: 'HTTPS의 TLS 핸드쉐이크 과정에서는 공개키(비대칭키) 암호화 방식을 통해 세션키(대칭키)를 안전하게 교환합니다.' },
            { id: 9, cat: '네트워크', concept: 'IP', level: '초급', q: 'IPv4 주소 체계의 비트(bit) 수는?', options: ['16비트', '32비트', '64비트', '128비트'], a: 1, exp: 'IPv4는 32비트 주소 체계를 가지며, IPv6는 128비트 체계를 가집니다.' },
            { id: 10, cat: '네트워크', concept: 'ARP', level: '중급', q: 'IP 주소를 MAC 주소로 변환하는 프로토콜은?', options: ['RARP', 'ICMP', 'IGMP', 'ARP'], a: 3, exp: 'ARP(Address Resolution Protocol)는 논리적인 IP 주소를 물리적인 MAC 주소로 매핑합니다.' },

            // [운영체제]
            { id: 11, cat: '운영체제', concept: '프로세스/스레드', level: '초급', q: '프로세스와 스레드에 대한 설명으로 틀린 것은?', options: ['프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이다.', '스레드는 프로세스 내에서 실행되는 흐름의 단위이다.', '스레드끼리는 프로세스의 Code, Data, Heap 영역을 공유한다.', '하나의 프로세스 내의 스레드들은 각자의 개별적인 Heap 영역을 가진다.'], a: 3, exp: '스레드는 Stack과 PC(Program Counter) 레지스터만 독립적으로 가지고, Heap 영역은 공유합니다.' },
            { id: 12, cat: '운영체제', concept: '데드락', level: '중급', q: '교착상태(Deadlock)의 발생 조건 4가지가 아닌 것은?', options: ['상호배제 (Mutual Exclusion)', '점유대기 (Hold and Wait)', '선점 (Preemption)', '순환대기 (Circular Wait)'], a: 2, exp: '데드락의 조건은 비선점(No Preemption)입니다. 자원을 강제로 뺏을 수 없어야 데드락이 발생합니다.' },
            { id: 13, cat: '운영체제', concept: '컨텍스트 스위칭', level: '중급', q: 'CPU가 현재 실행 중인 프로세스의 상태를 저장하고, 다음 실행할 프로세스의 상태를 복원하는 과정은?', options: ['페이징', '컨텍스트 스위칭', '스와핑', '인터럽트'], a: 1, exp: 'Context Switching(문맥 교환)은 PCB에 현재 상태를 저장하고 새로운 프로세스의 상태를 적재하는 작업입니다.' },
            { id: 14, cat: '운영체제', concept: '동기화', level: '중급', q: '공유 자원에 대한 접근을 제어하기 위해 0과 1의 값만 가질 수 있는 락(Lock) 메커니즘은?', options: ['세마포어 (Semaphore)', '모니터 (Monitor)', '뮤텍스 (Mutex)', '파이프 (Pipe)'], a: 2, exp: '뮤텍스는 이진 세마포어라고도 불리며, 오직 하나의 스레드/프로세스만 임계 영역에 접근할 수 있게 하는 락입니다.' },
            { id: 15, cat: '운영체제', concept: '메모리 관리', level: '고급', q: '가상 메모리 관리 기법 중, 외부 단편화 문제를 해결하기 위해 메모리를 동일한 크기의 블록으로 나누는 기법은?', options: ['세그먼테이션 (Segmentation)', '페이징 (Paging)', '스와핑 (Swapping)', '압축 (Compaction)'], a: 1, exp: '페이징은 메모리를 고정 크기의 페이지 프레임으로 나누어 외부 단편화를 해결합니다. (내부 단편화는 발생 가능)' },
            { id: 16, cat: '운영체제', concept: 'CPU 스케줄링', level: '초급', q: '각 프로세스에 동일한 할당 시간(Time Quantum)을 부여하고, 시간이 다 되면 큐의 맨 뒤로 보내는 스케줄링 알고리즘은?', options: ['FCFS', 'SJF', 'Round Robin', 'Priority Scheduling'], a: 2, exp: '라운드 로빈(Round Robin)은 시분할 시스템을 위해 설계된 선점형 스케줄링 방식입니다.' },
            { id: 17, cat: '운영체제', concept: '메모리 관리', level: '고급', q: '페이지 부재(Page Fault)가 너무 빈번하게 발생하여 CPU가 연산보다 페이징 교체 작업에 더 많은 시간을 할애하는 현상은?', options: ['스와핑 (Swapping)', '스래싱 (Thrashing)', '데드락 (Deadlock)', '기아 상태 (Starvation)'], a: 1, exp: '스래싱은 다중 프로그래밍 정도(MPD)가 과도할 때 발생하는 심각한 성능 저하 현상입니다.' },
            { id: 18, cat: '운영체제', concept: '동기화', level: '고급', q: '프로세스들이 임계 구역(Critical Section)에 진입하기 위해 충족해야 하는 조건이 아닌 것은?', options: ['상호 배제 (Mutual Exclusion)', '진행 (Progress)', '한정 대기 (Bounded Waiting)', '우선 순위 (Priority)'], a: 3, exp: '임계 구역 문제 해결 조건은 상호 배제, 진행, 한정 대기 3가지입니다.' },
            { id: 19, cat: '운영체제', concept: '인터럽트', level: '중급', q: '운영체제에서 시스템 콜(System Call)을 발생시키는 방법은?', options: ['하드웨어 인터럽트', '소프트웨어 인터럽트 (Trap)', 'DMA (Direct Memory Access)', '폴링 (Polling)'], a: 1, exp: '사용자 프로그램이 운영체제 서비스를 요청하기 위해 소프트웨어 인터럽트인 트랩(Trap)을 발생시켜 시스템 콜을 호출합니다.' },
            { id: 20, cat: '운영체제', concept: '프로세스/스레드', level: '중급', q: '프로세스 제어 블록(PCB)에 저장되지 않는 정보는?', options: ['프로세스 식별자(PID)', '프로세스 상태', '지역 변수 데이터', '프로그램 카운터(PC)'], a: 2, exp: '지역 변수는 프로세스의 Stack 영역에 저장되며, PCB는 운영체제가 프로세스를 관리하기 위한 메타데이터를 담습니다.' },

            // [데이터베이스]
            { id: 21, cat: '데이터베이스', concept: '트랜잭션', level: '초급', q: '데이터베이스 트랜잭션의 특징(ACID) 중, 트랜잭션의 연산이 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 함을 의미하는 것은?', options: ['원자성 (Atomicity)', '일관성 (Consistency)', '격리성 (Isolation)', '지속성 (Durability)'], a: 0, exp: '원자성(Atomicity)은 "All or Nothing"으로, 트랜잭션 내의 모든 명령이 완벽히 수행되거나 모두 취소되어야 함을 뜻합니다.' },
            { id: 22, cat: '데이터베이스', concept: '인덱스', level: '중급', q: 'RDBMS에서 인덱스를 구현할 때 가장 범용적으로 많이 사용되는 자료구조는?', options: ['Hash Table', 'B-Tree (B+Tree)', 'Linked List', 'Stack'], a: 1, exp: 'B-Tree(특히 B+Tree)는 데이터의 범위 검색(Range Scan)에 유리하여 RDBMS 인덱스 구조로 가장 널리 쓰입니다.' },
            { id: 23, cat: '데이터베이스', concept: '정규화', level: '초급', q: '릴레이션의 모든 속성이 원자값(Atomic Value)만을 갖도록 분해하는 정규화 과정은?', options: ['제1정규형 (1NF)', '제2정규형 (2NF)', '제3정규형 (3NF)', 'BCNF'], a: 0, exp: '제1정규형(1NF)은 릴레이션에 속한 모든 속성의 도메인이 원자값으로만 구성되도록 하는 것입니다.' },
            { id: 24, cat: '데이터베이스', concept: '트랜잭션 격리', level: '고급', q: '트랜잭션 격리 수준(Isolation Level) 중 하나인 Phantom Read 현상이 발생할 수 있는 격리 수준은?', options: ['READ UNCOMMITTED', 'READ COMMITTED', 'REPEATABLE READ', 'SERIALIZABLE'], a: 2, exp: 'REPEATABLE READ 격리 수준에서는 Non-Repeatable Read는 방지되지만, 다른 트랜잭션이 새로운 레코드를 삽입할 때 발생하는 Phantom Read는 발생할 수 있습니다 (단, InnoDB의 경우 갭 락으로 방지함).' },
            { id: 25, cat: '데이터베이스', concept: 'SQL', level: '초급', q: '두 테이블에서 일치하는 행만 반환하는 JOIN 방식은?', options: ['LEFT OUTER JOIN', 'RIGHT OUTER JOIN', 'INNER JOIN', 'CROSS JOIN'], a: 2, exp: 'INNER JOIN은 조인 조건에 일치하는 데이터만을 추출합니다.' },
            { id: 26, cat: '데이터베이스', concept: 'DB 설계', level: '중급', q: 'NoSQL 데이터베이스의 특징과 거리가 먼 것은?', options: ['스키마가 없거나 유연하다 (Schema-less).', '수평적 확장(Scale-out)에 용이하다.', '엄격한 ACID 트랜잭션을 항상 보장한다.', '대용량의 비정형 데이터를 저장하기 적합하다.'], a: 2, exp: '대부분의 NoSQL은 엄격한 ACID 대신 성능과 가용성을 위해 BASE 속성이나 최종적 일관성(Eventual Consistency)을 따릅니다.' },
            { id: 27, cat: '데이터베이스', concept: 'DB 객체', level: '초급', q: '하나 이상의 기본 테이블로부터 유도되어 만들어진 가상의 테이블은?', options: ['인덱스 (Index)', '뷰 (View)', '트리거 (Trigger)', '프로시저 (Procedure)'], a: 1, exp: '뷰(View)는 물리적으로 데이터를 저장하지 않지만, 사용자에게는 테이블과 동일하게 보여지는 가상 테이블입니다.' },
            { id: 28, cat: '데이터베이스', concept: '분산 DB', level: '고급', q: '분산 데이터베이스 시스템이 가지는 3가지 특징 중, 동시에 3가지를 모두 만족할 수 없다는 이론은?', options: ['ACID 속성', 'CAP 정리', 'BASE 모델', 'Paxos 알고리즘'], a: 1, exp: 'CAP 정리(Theorem)는 일관성(Consistency), 가용성(Availability), 분할 내성(Partition tolerance)을 동시에 완벽히 만족할 수 없다는 정리입니다.' },
            { id: 29, cat: '데이터베이스', concept: '트랜잭션', level: '초급', q: '완료된 트랜잭션의 결과는 시스템이 고장 나더라도 영구적으로 반영되어야 한다는 특징은?', options: ['원자성', '일관성', '격리성', '지속성'], a: 3, exp: '지속성(Durability)은 트랜잭션이 성공적으로 커밋되면 그 결과는 시스템에 영구히 보존되어야 한다는 속성입니다.' },
            { id: 30, cat: '데이터베이스', concept: '정규화', level: '중급', q: '이행적 함수 종속성(Transitive Dependency)을 제거하는 정규형은?', options: ['제1정규형', '제2정규형', '제3정규형', 'BCNF'], a: 2, exp: '제3정규형(3NF)은 제2정규형을 만족하며, 기본키가 아닌 일반 속성들 간의 함수 종속성(이행적 종속)을 제거합니다.' },

            // [자료구조]
            { id: 31, cat: '자료구조', concept: '배열/리스트', level: '초급', q: '크기가 동적으로 변할 수 있으며, 데이터의 삽입과 삭제가 O(1)에 가능한(노드 위치를 알 때) 자료구조는?', options: ['Array', 'Linked List', 'Stack', 'Queue'], a: 1, exp: 'Linked List(연결 리스트)는 노드를 포인터로 연결하여 동적인 크기를 가지며 중간 삽입/삭제가 용이합니다.' },
            { id: 32, cat: '자료구조', concept: '스택/큐', level: '초급', q: '나중에 들어간 데이터가 먼저 나오는 LIFO(Last In First Out) 구조의 자료구조는?', options: ['Queue', 'Deque', 'Stack', 'Heap'], a: 2, exp: 'Stack은 프링글스 통처럼 나중에 넣은 데이터를 가장 먼저 꺼내는 LIFO 구조입니다. (ex: 함수 호출 스택)' },
            { id: 33, cat: '자료구조', concept: '해시', level: '중급', q: '해시 테이블에서 서로 다른 두 개의 키가 같은 해시 값을 가지는 현상을 무엇이라 하는가?', options: ['오버플로우 (Overflow)', '언더플로우 (Underflow)', '해시 충돌 (Hash Collision)', '해시 체이닝 (Hash Chaining)'], a: 2, exp: '해시 충돌은 서로 다른 입력값이 해시 함수에 의해 동일한 버킷으로 매핑되는 현상입니다.' },
            { id: 34, cat: '자료구조', concept: '트리', level: '초급', q: '이진 탐색 트리(BST)에서 특정 노드를 검색할 때, 평균적인 시간 복잡도는?', options: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'], a: 1, exp: '균형 잡힌 이진 탐색 트리의 탐색 시간 복잡도는 트리의 높이인 O(log n)입니다. (최악의 경우 편향 트리면 O(n))' },
            { id: 35, cat: '자료구조', concept: '힙', level: '중급', q: '우선순위 큐(Priority Queue)를 구현할 때 가장 효율적인 자료구조는?', options: ['Array', 'Linked List', 'Hash Table', 'Heap'], a: 3, exp: '힙(Heap)은 최대값이나 최솟값을 O(log n)만에 삽입/삭제할 수 있어 우선순위 큐 구현에 최적입니다.' },
            { id: 36, cat: '자료구조', concept: '그래프', level: '초급', q: '그래프 탐색 알고리즘 중 큐(Queue)를 사용하여 가까운 노드부터 탐색하는 알고리즘은?', options: ['DFS (깊이 우선 탐색)', 'BFS (너비 우선 탐색)', 'Dijkstra (다익스트라)', 'Kruskal (크루스칼)'], a: 1, exp: 'BFS는 큐를 활용하여 시작 정점으로부터 인접한 정점을 먼저 방문하는 탐색 기법입니다.' },
            { id: 37, cat: '자료구조', concept: '트리 탐색', level: '중급', q: '이진 트리를 순회할 때, [왼쪽 자식 -> 루트 -> 오른쪽 자식] 순서로 방문하는 방식은?', options: ['전위 순회 (Preorder)', '중위 순회 (Inorder)', '후위 순회 (Postorder)', '레벨 순회 (Level order)'], a: 1, exp: '중위 순회(Inorder)는 왼쪽 서브트리를 다 본 후 부모(루트)를 보고, 그 다음 오른쪽 서브트리를 봅니다.' },
            { id: 38, cat: '자료구조', concept: '스택/큐', level: '초급', q: '큐(Queue) 자료구조에서 데이터를 삽입하는 연산을 가리키는 용어는?', options: ['Push', 'Pop', 'Enqueue', 'Dequeue'], a: 2, exp: '큐에 데이터를 넣는 작업을 Enqueue, 빼는 작업을 Dequeue라고 합니다.' },
            { id: 39, cat: '자료구조', concept: '해시', level: '고급', q: '해시 충돌을 해결하기 위해 연결 리스트를 사용하여 같은 버킷에 데이터를 매달아 놓는 기법은?', options: ['개방 주소법 (Open Addressing)', '선형 탐사 (Linear Probing)', '체이닝 (Chaining)', '이중 해싱 (Double Hashing)'], a: 2, exp: '체이닝(Chaining) 기법은 충돌이 발생하면 해당 버킷을 연결 리스트로 만들어 데이터를 추가하는 방법입니다.' },
            { id: 40, cat: '자료구조', concept: '알고리즘', level: '고급', q: '배열의 요소들을 정렬할 때, 최악의 경우에도 시간 복잡도가 O(n log n)을 보장하는 정렬 알고리즘은?', options: ['버블 정렬 (Bubble Sort)', '선택 정렬 (Selection Sort)', '퀵 정렬 (Quick Sort)', '병합 정렬 (Merge Sort)'], a: 3, exp: '병합 정렬(Merge Sort)은 항상 절반으로 분할하여 병합하므로 최악의 경우에도 O(n log n)을 보장합니다. (퀵 정렬은 최악의 경우 O(n^2)입니다.)' }
        ];

        // AI 이론 요약 데이터베이스 (개념에 대한 하드코딩된 설명 풀)
        const conceptTheories = {
            'TCP/IP': '네트워크 통신의 기본 프로토콜. 특히 TCP는 연결 지향적이며 신뢰성 있는 통신(3-way handshake)을 보장합니다.',
            'OSI 7계층': '통신 과정을 7단계로 표준화한 모델입니다. 물리-데이터링크-네트워크-전송-세션-표현-응용 계층으로 나뉩니다.',
            'HTTP': '웹에서 데이터를 주고받기 위한 프로토콜. 상태를 가지지 않으며(Stateless), GET, POST 등의 메서드를 사용합니다.',
            '프로세스/스레드': '프로세스는 실행 중인 프로그램(자원 할당 단위)이며, 스레드는 프로세스 내의 실행 단위입니다. 스레드는 메모리를 공유해 경량화된 컨텍스트 스위칭이 가능합니다.',
            '데드락': '둘 이상의 프로세스가 서로의 자원을 요구하며 무한 대기하는 상태. 상호배제, 점유대기, 비선점, 순환대기 4가지 조건이 성립할 때 발생합니다.',
            '메모리 관리': '제한된 메모리를 효율적으로 사용하기 위한 기법. 페이징(고정 크기)과 세그먼테이션(가변 크기)이 대표적입니다.',
            '트랜잭션': 'DB의 상태를 변화시키는 작업의 논리적 단위. ACID(원자성, 일관성, 격리성, 지속성) 성질을 보장해야 합니다.',
            '인덱스': 'DB 테이블의 검색 속도를 높이기 위한 자료구조. B-Tree, B+Tree가 주로 사용되며 데이터 갱신 시 오버헤드가 발생할 수 있습니다.',
            '정규화': '데이터의 중복을 줄이고 무결성을 유지하기 위해 테이블을 구조화하는 과정. 삽입, 갱신, 삭제 이상 현상을 방지합니다.',
            '배열/리스트': '배열은 연속된 메모리에 저장되어 인덱스 접근이 O(1)이지만 크기가 고정됩니다. 연결 리스트는 동적 크기를 가지며 삽입/삭제가 유연합니다.',
            '해시': '키를 해시 함수에 통과시켜 인덱스를 구하고 해당 버킷에 데이터를 저장합니다. 해시 충돌 관리가 핵심입니다.',
            '트리': '노드들이 계층적으로 연결된 비선형 자료구조. 이진 탐색 트리(BST)는 탐색 효율을 O(log n)으로 높여줍니다.'
        };


        // --- 2. APPLICATION STATE ---
        const appState = {
            currentScreen: 'home',
            pendingCategory: null,
            activeQuiz: [],
            currentIndex: 0,
            userAnswers: [],
            archive: JSON.parse(localStorage.getItem('cs_archive')) || []
        };

        // --- 3. UI CONTROLLER ---
        const app = {
            // 화면 전환
            navigate(screenId) {
                document.querySelectorAll('main > div').forEach(el => el.classList.add('hidden'));
                document.getElementById(`screen-${screenId}`).classList.remove('hidden');
                appState.currentScreen = screenId;
                window.scrollTo(0, 0);

                if (screenId === 'archive') {
                    this.renderArchive();
                }
            },

            // 무작위 문제 섞기 (Fisher-Yates)
            shuffle(array) {
                let currentIndex = array.length, randomIndex;
                while (currentIndex != 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                }
                return array;
            },

            // 설정 모달 열기
            openQuizSettings(category) {
                appState.pendingCategory = category;
                document.getElementById('modal-category-title').innerText = `${category} 모의고사 설정`;
                document.getElementById('quiz-settings-modal').classList.remove('hidden');
            },

            // 설정 모달 닫기
            closeQuizSettings() {
                document.getElementById('quiz-settings-modal').classList.add('hidden');
            },

            // 설정 적용 후 퀴즈 시작
            applySettingsAndStart() {
                const diff = document.getElementById('setting-difficulty').value;
                const count = parseInt(document.getElementById('setting-count').value, 10);
                
                this.closeQuizSettings();
                this.startQuiz(appState.pendingCategory, diff, count);
            },

            // 퀴즈 시작
            startQuiz(category, difficulty, targetCount) {
                let pool = [];
                if (category === '종합') {
                    pool = [...questionsDB];
                } else {
                    pool = questionsDB.filter(q => q.cat === category);
                }

                if (difficulty !== '전체') {
                    pool = pool.filter(q => q.level === difficulty);
                }

                if (pool.length === 0) {
                    alert('선택하신 조건(카테고리/난이도)에 맞는 문제가 없습니다. 다른 난이도를 선택해주세요.');
                    return;
                }

                this.shuffle(pool);
                
                // 설정한 개수보다 가능한 문제가 적을 경우 처리
                const actualCount = Math.min(targetCount, pool.length);
                appState.activeQuiz = pool.slice(0, actualCount);
                appState.currentIndex = 0;
                appState.userAnswers = new Array(appState.activeQuiz.length).fill(null);
                
                // 뱃지 업데이트
                document.getElementById('quiz-category-badge').innerText = category;
                const diffBadge = document.getElementById('quiz-difficulty-badge');
                if (difficulty !== '전체') {
                    diffBadge.innerText = difficulty;
                    diffBadge.classList.remove('hidden');
                } else {
                    diffBadge.classList.add('hidden');
                }

                if (actualCount < targetCount) {
                    alert(`요청하신 조건에 맞는 문제가 ${actualCount}문제뿐이라, 해당 개수만큼만 퀴즈를 진행합니다.`);
                }

                this.renderQuestion();
                this.navigate('quiz');
            },

            // 질문 렌더링
            renderQuestion() {
                const q = appState.activeQuiz[appState.currentIndex];
                const total = appState.activeQuiz.length;
                
                // 진행도 업데이트
                document.getElementById('quiz-progress-text').innerText = `문제 ${appState.currentIndex + 1} / ${total}`;
                document.getElementById('quiz-progress-bar').style.width = `${((appState.currentIndex + 1) / total) * 100}%`;
                
                // 텍스트 업데이트
                document.getElementById('quiz-question').innerText = `Q. ${q.q}`;
                
                // 보기 렌더링
                const optionsContainer = document.getElementById('quiz-options');
                optionsContainer.innerHTML = '';
                
                q.options.forEach((opt, idx) => {
                    const btn = document.createElement('button');
                    btn.className = 'option-btn w-full text-left p-4 rounded-xl border-2 border-gray-200 bg-white hover:border-blue-500 font-medium text-gray-700';
                    btn.innerHTML = `<span class="inline-block w-6 h-6 rounded-full bg-gray-100 text-center leading-6 mr-3 text-sm">${idx+1}</span> ${opt}`;
                    btn.onclick = () => this.selectOption(idx, btn);
                    optionsContainer.appendChild(btn);
                });

                // 해설 박스 및 다음 문제 버튼 숨기기
                document.getElementById('quiz-explanation').classList.add('hidden');
                document.getElementById('btn-next-question').classList.add('hidden');
            },

            // 보기 선택
            selectOption(index, btnElement) {
                // 이미 선택된 상태면 리턴
                if(appState.userAnswers[appState.currentIndex] !== null) return;

                appState.userAnswers[appState.currentIndex] = index;
                
                const q = appState.activeQuiz[appState.currentIndex];
                const buttons = document.querySelectorAll('.option-btn');
                
                // 버튼 상태 비활성화 및 색상 표시
                buttons.forEach((btn, i) => {
                    btn.disabled = true;
                    btn.classList.remove('hover:border-blue-500');
                    if (i === q.a) {
                        btn.classList.add('bg-green-50', 'border-green-500', 'text-green-800');
                        btn.innerHTML += ' <i class="fas fa-check-circle text-green-500 float-right mt-1"></i>';
                    } else if (i === index && i !== q.a) {
                        btn.classList.add('bg-red-50', 'border-red-500', 'text-red-800');
                        btn.innerHTML += ' <i class="fas fa-times-circle text-red-500 float-right mt-1"></i>';
                    } else {
                        btn.classList.add('opacity-50');
                    }
                });

                // 해설 표시
                document.getElementById('quiz-explanation-text').innerText = q.exp;
                document.getElementById('quiz-explanation').classList.remove('hidden');

                const nextBtn = document.getElementById('btn-next-question');
                if (appState.currentIndex === appState.activeQuiz.length - 1) {
                    nextBtn.innerHTML = '결과 보기 <i class="fas fa-flag-checkered ml-1"></i>';
                } else {
                    nextBtn.innerHTML = '다음 문제 <i class="fas fa-chevron-right ml-1"></i>';
                }
                nextBtn.classList.remove('hidden');
            },

            // 다음 문제 또는 결과
            nextQuestion() {
                if (appState.currentIndex < appState.activeQuiz.length - 1) {
                    appState.currentIndex++;
                    this.renderQuestion();
                } else {
                    this.showResults();
                }
            },

            // 결과 화면 표시
            showResults() {
                let correctCount = 0;
                const resultList = document.getElementById('result-list');
                resultList.innerHTML = '';

                appState.activeQuiz.forEach((q, idx) => {
                    const isCorrect = appState.userAnswers[idx] === q.a;
                    if (isCorrect) correctCount++;

                    // 복습 노트 항목 생성
                    const item = document.createElement('div');
                    item.className = `p-5 rounded-xl border ${isCorrect ? 'border-green-200 bg-green-50/30' : 'border-red-200 bg-red-50/30'} flex flex-col`;
                    
                    const isArchived = appState.archive.includes(q.id);
                    
                    item.innerHTML = `
                        <div class="flex justify-between items-start mb-2">
                            <h4 class="font-bold text-gray-800 flex-1">
                                <span class="${isCorrect ? 'text-green-600' : 'text-red-600'} mr-2">
                                    <i class="fas ${isCorrect ? 'fa-check' : 'fa-times'}"></i>
                                </span>
                                Q${idx+1}. ${q.q}
                            </h4>
                            ${!isCorrect ? `
                                <button onclick="app.toggleArchive(${q.id}, this)" class="ml-4 text-sm px-3 py-1 rounded-full ${isArchived ? 'bg-indigo-100 text-indigo-700' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'} transition-colors whitespace-nowrap">
                                    <i class="fas fa-bookmark"></i> <span class="btn-text">${isArchived ? '저장됨' : '저장하기'}</span>
                                </button>
                            ` : ''}
                        </div>
                        <div class="text-sm text-gray-600 mt-2 pl-6">
                            <p class="mb-1"><span class="font-semibold">내 답변:</span> ${q.options[appState.userAnswers[idx]]}</p>
                            ${!isCorrect ? `<p class="mb-2 text-green-700"><span class="font-semibold">정답:</span> ${q.options[q.a]}</p>` : ''}
                            <div class="bg-white p-3 rounded-lg border border-gray-100 mt-2 text-gray-700 shadow-sm text-sm">
                                <i class="fas fa-lightbulb text-yellow-500 mr-1"></i> ${q.exp}
                            </div>
                        </div>
                    `;
                    resultList.appendChild(item);
                });

                const score = (correctCount / appState.activeQuiz.length) * 100;
                document.getElementById('result-score').innerText = `${score}점`;
                
                let msg = "";
                if (score >= 90) msg = "완벽합니다! 백엔드 전공 지식이 매우 탄탄하시네요.";
                else if (score >= 70) msg = "훌륭합니다! 조금만 더 복습하면 완벽할 것 같아요.";
                else if (score >= 50) msg = "잘하셨습니다. 틀린 문제는 아카이브에 저장하고 복습해보세요.";
                else msg = "기본 개념을 다시 한 번 되짚어볼 수 있는 좋은 기회입니다. 파이팅!";
                
                document.getElementById('result-msg').innerText = msg;

                this.navigate('result');
            },

            // 아카이브 토글 (저장/삭제)
            toggleArchive(qId, btnEl) {
                const idx = appState.archive.indexOf(qId);
                if (idx > -1) {
                    appState.archive.splice(idx, 1);
                    if(btnEl) {
                        btnEl.classList.replace('bg-indigo-100', 'bg-gray-200');
                        btnEl.classList.replace('text-indigo-700', 'text-gray-700');
                        btnEl.querySelector('.btn-text').innerText = '저장하기';
                    }
                } else {
                    appState.archive.push(qId);
                    if(btnEl) {
                        btnEl.classList.replace('bg-gray-200', 'bg-indigo-100');
                        btnEl.classList.replace('text-gray-700', 'text-indigo-700');
                        btnEl.querySelector('.btn-text').innerText = '저장됨';
                    }
                }
                localStorage.setItem('cs_archive', JSON.stringify(appState.archive));
                
                // 만약 현재 화면이 아카이브면 즉시 리렌더링
                if(appState.currentScreen === 'archive') {
                    this.renderArchive();
                }
            },

            // 아카이브 화면 렌더링
            renderArchive() {
                const listContainer = document.getElementById('archive-list');
                const emptyState = document.getElementById('archive-empty');
                const aiPanel = document.getElementById('ai-analysis-panel');
                
                listContainer.innerHTML = '';
                // AI 패널 초기화 및 숨김
                aiPanel.classList.add('hidden');
                document.getElementById('ai-recommendations').classList.add('hidden');

                if (appState.archive.length === 0) {
                    emptyState.classList.remove('hidden');
                    return;
                }

                emptyState.classList.add('hidden');

                // 역순 렌더링 (최근 저장한 순)
                const archivedQuestions = [...appState.archive].reverse().map(id => questionsDB.find(q => q.id === id)).filter(Boolean);

                archivedQuestions.forEach(q => {
                    const card = document.createElement('div');
                    card.className = 'bg-white p-5 rounded-xl border border-gray-200 shadow-sm relative hover:shadow-md transition-shadow';
                    card.innerHTML = `
                        <div class="absolute top-4 right-4 text-gray-400 hover:text-red-500 cursor-pointer transition-colors" onclick="app.toggleArchive(${q.id})" title="아카이브에서 제거">
                            <i class="fas fa-trash-alt"></i>
                        </div>
                        <span class="inline-block px-2 py-1 bg-gray-100 text-gray-600 text-xs font-bold rounded mb-3">${q.cat} > ${q.concept}</span>
                        <h4 class="font-bold text-gray-800 mb-3 text-sm pr-6 leading-relaxed">${q.q}</h4>
                        <div class="bg-blue-50/50 p-3 rounded-lg border border-blue-100 text-gray-700 text-sm">
                            <p class="text-blue-700 font-semibold mb-1 text-xs">정답: ${q.options[q.a]}</p>
                            ${q.exp}
                        </div>
                    `;
                    listContainer.appendChild(card);
                });
            },

            // 가상 AI 분석 및 연관 문제 추천 로직
            runAIAnalysis() {
                if (appState.archive.length === 0) {
                    alert('분석할 데이터가 부족합니다. 먼저 퀴즈를 풀고 오답을 저장해주세요.');
                    return;
                }

                const aiPanel = document.getElementById('ai-analysis-panel');
                const aiContent = document.getElementById('ai-analysis-content');
                const aiRecs = document.getElementById('ai-recommendations');
                const recsContainer = document.getElementById('ai-recommended-questions');
                
                aiPanel.classList.remove('hidden');
                aiRecs.classList.add('hidden');
                aiContent.innerHTML = '저장된 오답 데이터를 바탕으로 취약점을 분석하고 있습니다...';
                aiContent.classList.add('typing-effect');

                // 1초 후 가짜 분석 결과 표시 (로딩 연출)
                setTimeout(() => {
                    // 1. 취약점 빈도 분석
                    const conceptCount = {};
                    appState.archive.forEach(id => {
                        const q = questionsDB.find(q => q.id === id);
                        if(q) {
                            conceptCount[q.concept] = (conceptCount[q.concept] || 0) + 1;
                        }
                    });

                    // 정렬 (가장 많이 틀린 개념)
                    const sortedConcepts = Object.entries(conceptCount).sort((a, b) => b[1] - a[1]);
                    const topConcepts = sortedConcepts.slice(0, 2).map(item => item[0]);

                    // 2. 텍스트 생성
                    aiContent.classList.remove('typing-effect');
                    let summaryText = `<strong>💡 학습 분석 결과:</strong><br>`;
                    summaryText += `현재 사용자님의 오답 노트를 분석해본 결과, 주로 <span class="text-indigo-600 font-bold">[${topConcepts.join(', ')}]</span> 파트에서 취약점이 발견되었습니다.<br><br>`;
                    
                    topConcepts.forEach(concept => {
                        const theory = conceptTheories[concept] || '해당 개념에 대한 기초 서적이나 강의를 다시 한 번 정독하시는 것을 추천합니다.';
                        summaryText += `- <strong>${concept}</strong>: ${theory}<br>`;
                    });
                    
                    aiContent.innerHTML = summaryText;

                    // 3. 연관 문제 추천 (취약점과 관련된 문제 위주로 추출)
                    recsContainer.innerHTML = '';
                    let recommended = [];
                    
                    // 1순위: 취약 개념과 정확히 일치하는 미풀이/미저장 문제
                    topConcepts.forEach(concept => {
                        const matchingQs = questionsDB.filter(q => q.concept === concept && !appState.archive.includes(q.id));
                        recommended.push(...matchingQs);
                    });

                    // 2순위: 정확한 개념의 문제가 부족할 경우, 취약점이 속한 '카테고리'의 다른 문제 추천
                    if (recommended.length < 2) {
                        const weakCategories = [...new Set(topConcepts.map(c => questionsDB.find(q => q.concept === c)?.cat).filter(Boolean))];
                        weakCategories.forEach(cat => {
                            const categoryQs = questionsDB.filter(q => q.cat === cat && !appState.archive.includes(q.id) && !recommended.some(r => r.id === q.id));
                            recommended.push(...categoryQs);
                        });
                    }

                    // 중복 제거 및 무작위 섞기
                    recommended = [...new Set(recommended)];
                    this.shuffle(recommended);
                    recommended = recommended.slice(0, 2);

                    // 3순위 (데이터가 아예 없을 경우 대비): 취약 카테고리 내에서 이미 푼 문제라도 복습용으로 다시 제공
                    if(recommended.length === 0) {
                        const weakCategories = [...new Set(topConcepts.map(c => questionsDB.find(q => q.concept === c)?.cat).filter(Boolean))];
                        let reviewQs = questionsDB.filter(q => weakCategories.includes(q.cat));
                        this.shuffle(reviewQs);
                        recommended = reviewQs.slice(0, 2);
                    }

                    if(recommended.length > 0) {
                        aiRecs.classList.remove('hidden');
                        recommended.forEach(q => {
                            const qDiv = document.createElement('div');
                            qDiv.className = 'bg-white p-4 rounded-lg border border-gray-200 shadow-sm';
                            qDiv.innerHTML = `
                                <div class="flex justify-between">
                                    <span class="text-xs font-bold text-indigo-500 mb-2 block">${q.cat} > ${q.concept}</span>
                                    <button onclick="app.revealAnswer(this)" class="text-xs bg-gray-100 hover:bg-gray-200 px-2 py-1 rounded text-gray-600 transition-colors">정답 보기</button>
                                </div>
                                <p class="text-sm font-semibold text-gray-800 mb-2">${q.q}</p>
                                <div class="hidden mt-3 p-3 bg-gray-50 rounded border border-gray-100 text-sm answer-box">
                                    <p class="font-bold text-green-700 mb-1">정답: ${q.options[q.a]}</p>
                                    <p class="text-gray-600">${q.exp}</p>
                                </div>
                            `;
                            recsContainer.appendChild(qDiv);
                        });
                    }

                }, 1500);
            },

            // 추천 문제 정답 보기 토글
            revealAnswer(btnEl) {
                const answerBox = btnEl.closest('div').nextElementSibling.nextElementSibling;
                if (answerBox.classList.contains('hidden')) {
                    answerBox.classList.remove('hidden');
                    btnEl.innerText = '정답 숨기기';
                } else {
                    answerBox.classList.add('hidden');
                    btnEl.innerText = '정답 보기';
                }
            }
        };

        // 초기화
        window.onload = () => {
            app.navigate('home');
        };

    </script>
</body>
</html>