<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‚¬ì²œì„± ê²Œì„</title>
    <style>
        :root {
            --bg-color: #f0f4f8;
            --board-bg: #e2e8f0;
            --tile-bg: #ffffff;
            --tile-border: #cbd5e1;
            --tile-shadow: rgba(0, 0, 0, 0.1);
            --primary-color: #3b82f6;
            --primary-hover: #2563eb;
            --text-color: #1e293b;
            --success-color: #10b981;
            --cell-size: 50px;
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            margin-top: 0;
            color: #0f172a;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px var(--tile-shadow);
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="number"] {
            width: 70px;
            padding: 8px;
            border: 1px solid var(--tile-border);
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            font-weight: bold;
        }

        button:hover {
            background-color: var(--primary-hover);
        }

        button:active {
            transform: scale(0.95);
        }

        button.secondary {
            background-color: #64748b;
        }

        button.secondary:hover {
            background-color: #475569;
        }

        .status-board {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            color: var(--primary-color);
            height: 24px;
        }

        #game-wrapper {
            position: relative;
            background-color: var(--board-bg);
            padding: 10px;
            border-radius: 12px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
            display: inline-block;
        }

        #board {
            display: grid;
            gap: 4px;
            position: relative;
            z-index: 10;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            box-sizing: border-box;
            user-select: none;
        }

        .tile {
            background-color: var(--tile-bg);
            border: 2px solid var(--tile-border);
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px var(--tile-shadow);
            transition: transform 0.1s, border-color 0.2s;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tile:hover {
            transform: translateY(-2px);
            border-color: #94a3b8;
        }

        .tile.selected {
            border-color: var(--primary-color);
            background-color: #eff6ff;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
            transform: scale(1.05);
            z-index: 20;
        }

        .tile.empty {
            visibility: hidden;
            pointer-events: none;
        }

        #svg-layer {
            position: absolute;
            top: 10px; /* game-wrapper padding */
            left: 10px;
            width: calc(100% - 20px);
            height: calc(100% - 20px);
            pointer-events: none;
            z-index: 30;
        }

        polyline {
            fill: none;
            stroke: #ef4444; /* Red path */
            stroke-width: 4;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawPath 0.3s forwards;
        }

        @keyframes drawPath {
            to {
                stroke-dashoffset: 0;
            }
        }

        #message-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #message-overlay.show {
            opacity: 1;
            pointer-events: all;
        }

        #message-overlay h2 {
            color: var(--success-color);
            font-size: 32px;
            margin-bottom: 10px;
        }

        /* ë°˜ì‘í˜•: í™”ë©´ì´ ì‘ì„ ë•Œ ì…€ í¬ê¸° ì¤„ì´ê¸° */
        @media (max-width: 600px) {
            :root {
                --cell-size: 40px;
            }
            .cell {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>

    <h1>ì‚¬ì²œì„± ê²Œì„ ğŸ§©</h1>

    <div class="controls">
        <div class="input-group">
            <label for="tile-count">íƒ€ì¼ ê°œìˆ˜ (2~50 ì§ìˆ˜):</label>
            <input type="number" id="tile-count" min="2" max="50" step="2" value="20">
        </div>
        <div class="input-group">
            <label for="time-limit">ì œí•œ ì‹œê°„(ì´ˆ, 0=ë¬´ì œí•œ):</label>
            <input type="number" id="time-limit" min="0" max="300" step="10" value="60">
        </div>
        <button onclick="startGame()">ìƒˆ ê²Œì„ ì‹œì‘</button>
        <button class="secondary" onclick="shuffleRemaining()">íƒ€ì¼ ì„ê¸°</button>
    </div>

    <div class="status-board">
        <span id="status-text">ì„¤ì •ì„ ì™„ë£Œí•˜ê³  ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”.</span>
        <span id="timer-display" style="margin-left: 20px;"></span>
    </div>

    <div id="game-wrapper" style="display: none;">
        <div id="board"></div>
        <svg id="svg-layer">
            <polyline id="path-line" points=""></polyline>
        </svg>
        <div id="message-overlay">
            <h2>ê²Œì„ í´ë¦¬ì–´! ğŸ‰</h2>
            <p>ëª¨ë“  íƒ€ì¼ì„ ì œê±°í–ˆìŠµë‹ˆë‹¤.</p>
            <button onclick="startGame()" style="margin-top: 15px;">ë‹¤ì‹œ í•˜ê¸°</button>
        </div>
    </div>

    <script>
        const EMOJIS = ['ğŸ','ğŸŠ','ğŸ‡','ğŸ‰','ğŸ“','ğŸ’','ğŸ‘','ğŸ','ğŸ¥','ğŸ…','ğŸ†','ğŸ¥‘','ğŸ¥¦','ğŸŒ½','ğŸ¥•','ğŸ„','ğŸ”','ğŸŸ','ğŸ•','ğŸŒ­','ğŸ¿','ğŸ©','ğŸª','ğŸ¬','ğŸ­'];
        
        let board = [];
        let cols = 0;
        let rows = 0;
        let tilesRemaining = 0;
        let selectedTile = null;
        let isProcessing = false;

        let timerInterval = null;
        let timeRemaining = 0;
        let isTimeAttack = false;

        // DOM ìš”ì†Œ
        const boardEl = document.getElementById('board');
        const gameWrapper = document.getElementById('game-wrapper');
        const tileCountInput = document.getElementById('tile-count');
        const statusText = document.getElementById('status-text');
        let pathLine = document.getElementById('path-line');
        const messageOverlay = document.getElementById('message-overlay');

        function startGame() {
            let count = parseInt(tileCountInput.value);
            let timeLimit = parseInt(document.getElementById('time-limit').value);
            
            // ì…ë ¥ê°’ ê²€ì¦
            if (isNaN(count) || count < 2) count = 2;
            if (count > 50) count = 50;
            if (count % 2 !== 0) count += 1;
            if (count > 50) count = 50;
            if (isNaN(timeLimit) || timeLimit < 0) timeLimit = 0;
            
            tileCountInput.value = count;
            document.getElementById('time-limit').value = timeLimit;
            
            tilesRemaining = count;
            selectedTile = null;
            isProcessing = false;
            
            // íƒ€ì´ë¨¸ ì´ˆê¸°í™”
            clearInterval(timerInterval);
            if (timeLimit > 0) {
                isTimeAttack = true;
                timeRemaining = timeLimit;
                updateTimerDisplay();
                timerInterval = setInterval(timerTick, 1000);
            } else {
                isTimeAttack = false;
                document.getElementById('timer-display').innerText = "ì‹œê°„ ì œí•œ: ì—†ìŒ";
                document.getElementById('timer-display').style.color = '';
            }

            messageOverlay.classList.remove('show');
            pathLine.setAttribute('points', '');

            // ê·¸ë¦¬ë“œ ì°¨ì› ê³„ì‚° (ë£¨íŠ¸ë¥¼ í™œìš©í•´ ìµœëŒ€í•œ ì •ì‚¬ê°í˜•ì— ê°€ê¹ê²Œ)
            cols = Math.ceil(Math.sqrt(count));
            rows = Math.ceil(count / cols);

            initBoardArray();
            populateBoard(count);
            renderBoard();
            
            gameWrapper.style.display = 'inline-block';
            updateStatusText();
        }

        // 2ì°¨ì› ë°°ì—´ ì´ˆê¸°í™” (ìƒí•˜ì¢Œìš°ì— ë¹ˆ ê³µê°„(0)ì„ 1ì¹¸ì”© ì¶”ê°€í•˜ì—¬ ë°”ê¹¥ìª½ ìš°íšŒ ê²½ë¡œ ì™„ë²½ ì§€ì›)
        function initBoardArray() {
            board = [];
            for (let y = 0; y <= rows + 1; y++) {
                board[y] = [];
                for (let x = 0; x <= cols + 1; x++) {
                    board[y][x] = 0; 
                }
            }
        }

        function populateBoard(count) {
            let pairTypes = [];
            const numPairs = count / 2;
            for (let i = 0; i < numPairs; i++) {
                pairTypes.push(EMOJIS[i % EMOJIS.length]);
            }
            placePairsSolvably(pairTypes, false);
        }

        // ë°ë“œë½ ë°©ì§€ë¥¼ ìœ„í•œ 'ì—­ë°©í–¥ ìƒì„±(Reverse Generation)' ì•Œê³ ë¦¬ì¦˜
        function placePairsSolvably(pairTypes, preserveShape) {
            let maxRetries = 150;
            let originalShape = [];
            
            for (let y = 1; y <= rows; y++) {
                for (let x = 1; x <= cols; x++) {
                    if (!preserveShape || board[y][x] !== 0) {
                        originalShape.push({x, y});
                    }
                }
            }

            for (let attempt = 0; attempt < maxRetries; attempt++) {
                // ê³µê°„ ë¹„ìš°ê¸°
                for (let p of originalShape) {
                    board[p.y][p.x] = 0;
                }

                let pairsToPlace = [...pairTypes];
                pairsToPlace.sort(() => Math.random() - 0.5);

                let success = true;
                let filledCells = new Set();

                for (let tile of pairsToPlace) {
                    let availableCells = originalShape.filter(p => !filledCells.has(`${p.x},${p.y}`));
                    let validPairs = [];

                    for (let c1 = 0; c1 < availableCells.length; c1++) {
                        for (let c2 = c1 + 1; c2 < availableCells.length; c2++) {
                            let p1 = availableCells[c1];
                            let p2 = availableCells[c2];
                            // ë¹ˆ ê³µê°„ë“¤ë¼ë¦¬ ì„œë¡œ ì—°ê²°ë˜ëŠ”ì§€ í™•ì¸
                            if (findPath(p1.x, p1.y, p2.x, p2.y) !== null) {
                                validPairs.push([p1, p2]);
                            }
                        }
                    }

                    if (validPairs.length === 0) {
                        success = false;
                        break;
                    }

                    let chosenPair = validPairs[Math.floor(Math.random() * validPairs.length)];
                    board[chosenPair[0].y][chosenPair[0].x] = tile;
                    board[chosenPair[1].y][chosenPair[1].x] = tile;
                    filledCells.add(`${chosenPair[0].x},${chosenPair[0].y}`);
                    filledCells.add(`${chosenPair[1].x},${chosenPair[1].y}`);
                }

                if (success) {
                    return true;
                }
            }
            
            console.warn("ì™„ë²½í•œ ìŒ ë°°ì¹˜ë¥¼ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ëœë¤ ë°°ì¹˜ë¡œ ì „í™˜í•©ë‹ˆë‹¤.");
            let activeTiles = [];
            for(let p of pairTypes) { activeTiles.push(p, p); }
            activeTiles.sort(() => Math.random() - 0.5);
            let idx = 0;
            for(let p of originalShape) {
                board[p.y][p.x] = activeTiles[idx++];
            }
            return false;
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            // ì™¸ê³½ ë§ˆì§„ ì…€ í¬í•¨ (cols + 2)
            boardEl.style.gridTemplateColumns = `repeat(${cols + 2}, var(--cell-size))`;
            boardEl.style.gridTemplateRows = `repeat(${rows + 2}, var(--cell-size))`;

            for (let y = 0; y <= rows + 1; y++) {
                for (let x = 0; x <= cols + 1; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${y}-${x}`;
                    
                    // ì™¸ê³½ ë§ˆì§„ì´ê±°ë‚˜, ë‚´ë¶€ë¼ë„ ë°ì´í„°ê°€ 0ì´ë©´ ë¹ˆ ê³µê°„
                    const tileVal = board[y][x];
                    if (tileVal !== 0 && y > 0 && y <= rows && x > 0 && x <= cols) {
                        const tileInner = document.createElement('div');
                        tileInner.className = 'tile';
                        tileInner.innerText = tileVal;
                        tileInner.onclick = () => handleTileClick(x, y);
                        cell.appendChild(tileInner);
                    }
                    boardEl.appendChild(cell);
                }
            }
        }

        function shuffleRemaining() {
            if (isProcessing || tilesRemaining === 0) return;
            
            let remainingCounts = {};
            for (let y = 1; y <= rows; y++) {
                for (let x = 1; x <= cols; x++) {
                    let t = board[y][x];
                    if (t !== 0) {
                        remainingCounts[t] = (remainingCounts[t] || 0) + 1;
                    }
                }
            }
            
            let pairTypes = [];
            for (let t in remainingCounts) {
                let pairs = remainingCounts[t] / 2;
                for (let i = 0; i < pairs; i++) {
                    pairTypes.push(t);
                }
            }
            
            // ê¸°ì¡´ íƒ€ì¼ ëª¨ì–‘(Shape)ì„ ìœ ì§€í•œ ì±„ 100% í•´ê²° ê°€ëŠ¥í•œ ìƒíƒœë¡œ ì¬ë°°ì¹˜
            placePairsSolvably(pairTypes, true);
            
            for (let y = 1; y <= rows; y++) {
                for (let x = 1; x <= cols; x++) {
                    const cell = document.getElementById(`cell-${y}-${x}`);
                    cell.innerHTML = ''; 
                    
                    if (board[y][x] !== 0) {
                        const tileInner = document.createElement('div');
                        tileInner.className = 'tile';
                        tileInner.innerText = board[y][x];
                        tileInner.onclick = () => handleTileClick(x, y);
                        cell.appendChild(tileInner);
                    }
                }
            }
            
            selectedTile = null;
            clearSelectionUI();
        }

        function handleTileClick(x, y) {
            if (isProcessing) return;
            if (board[y][x] === 0) return;

            if (selectedTile && selectedTile.x === x && selectedTile.y === y) {
                selectedTile = null;
                clearSelectionUI();
                return;
            }

            if (selectedTile) {
                const prevX = selectedTile.x;
                const prevY = selectedTile.y;
                
                if (board[prevY][prevX] === board[y][x]) {
                    const path = findPath(prevX, prevY, x, y);
                    
                    if (path) {
                        isProcessing = true;
                        drawPath(path);
                        
                        setTimeout(() => {
                            removeTiles(prevX, prevY, x, y);
                        }, 300);
                    } else {
                        changeSelection(x, y);
                    }
                } else {
                    changeSelection(x, y);
                }
            } else {
                changeSelection(x, y);
            }
        }

        function changeSelection(x, y) {
            clearSelectionUI();
            selectedTile = { x, y };
            const cellEl = document.getElementById(`cell-${y}-${x}`);
            if (cellEl && cellEl.firstElementChild) {
                cellEl.firstElementChild.classList.add('selected');
            }
        }

        function clearSelectionUI() {
            const selectedEls = document.querySelectorAll('.tile.selected');
            selectedEls.forEach(el => el.classList.remove('selected'));
        }

        function removeTiles(x1, y1, x2, y2) {
            board[y1][x1] = 0;
            board[y2][x2] = 0;

            const el1 = document.getElementById(`cell-${y1}-${x1}`).firstElementChild;
            const el2 = document.getElementById(`cell-${y2}-${x2}`).firstElementChild;
            
            if (el1) {
                el1.classList.remove('selected');
                el1.classList.add('empty');
            }
            if (el2) {
                el2.classList.remove('selected');
                el2.classList.add('empty');
            }

            pathLine.setAttribute('points', '');
            selectedTile = null;
            tilesRemaining -= 2;
            updateStatusText();
            isProcessing = false;

            if (tilesRemaining === 0) {
                clearInterval(timerInterval);
                messageOverlay.innerHTML = `
                    <h2 style="color: var(--success-color);">ê²Œì„ í´ë¦¬ì–´! ğŸ‰</h2>
                    <p>ëª¨ë“  íƒ€ì¼ì„ ì œê±°í–ˆìŠµë‹ˆë‹¤.</p>
                    <button onclick="startGame()" style="margin-top: 15px;">ë‹¤ì‹œ í•˜ê¸°</button>
                `;
                messageOverlay.classList.add('show');
            }
        }

        function updateStatusText() {
            statusText.innerText = `ë‚¨ì€ íƒ€ì¼: ${tilesRemaining}ê°œ`;
        }

        // ==== ì „ë©´ ê°œí¸ëœ ëª…ì‹œì  ê²½ë¡œ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ ====

        // ë‘ ì  ì‚¬ì´ì˜ ì§ì„  ê²½ë¡œì— ì¥ì• ë¬¼ì´ ì—†ëŠ”ì§€ í™•ì¸ (ì–‘ ëì ì€ ì œì™¸í•˜ê³  ì¤‘ê°„ë§Œ ê²€ì‚¬)
        function isLineClear(x1, y1, x2, y2) {
            if (x1 !== x2 && y1 !== y2) return false; // ì§ì„ ì´ ì•„ë‹˜
            
            if (x1 === x2) {
                const yMin = Math.min(y1, y2);
                const yMax = Math.max(y1, y2);
                for (let y = yMin + 1; y < yMax; y++) {
                    if (board[y][x1] !== 0) return false;
                }
            } else {
                const xMin = Math.min(x1, x2);
                const xMax = Math.max(x1, x2);
                for (let x = xMin + 1; x < xMax; x++) {
                    if (board[y1][x] !== 0) return false;
                }
            }
            return true;
        }

        // ì¶œë°œì§€(x1,y1)ì—ì„œ ëª©ì ì§€(x2,y2)ë¡œ ìµœëŒ€ 2ë²ˆ êº¾ì–´ ê°ˆ ìˆ˜ ìˆëŠ”ì§€ íƒìƒ‰
        function findPath(x1, y1, x2, y2) {
            // 0ë²ˆ êº¾ì„ (ì§ì„  ì—°ê²°)
            if (isLineClear(x1, y1, x2, y2)) {
                return [{x: x1, y: y1}, {x: x2, y: y2}];
            }

            // 1ë²ˆ êº¾ì„ (ã„± í˜¹ì€ ã„´ ëª¨ì–‘ ì—°ê²°)
            // ì½”ë„ˆ 1: (x1, y2)
            if (board[y2][x1] === 0 && isLineClear(x1, y1, x1, y2) && isLineClear(x1, y2, x2, y2)) {
                return [{x: x1, y: y1}, {x: x1, y: y2}, {x: x2, y: y2}];
            }
            // ì½”ë„ˆ 2: (x2, y1)
            if (board[y1][x2] === 0 && isLineClear(x1, y1, x2, y1) && isLineClear(x2, y1, x2, y2)) {
                return [{x: x1, y: y1}, {x: x2, y: y1}, {x: x2, y: y2}];
            }

            // 2ë²ˆ êº¾ì„ (ã„·, ã„¹ ëª¨ì–‘ ë° ë°”ê¹¥ í…Œë‘ë¦¬ ìš°íšŒ)
            // 1. ì¤‘ê°„ ì„ ë¶„ì´ ê°€ë¡œì¶•(ìˆ˜í‰)ì¸ ê²½ìš° (ìœ„/ì•„ë˜ í…Œë‘ë¦¬ ìš°íšŒ í¬í•¨)
            for (let y = 0; y <= rows + 1; y++) {
                if (y !== y1 && y !== y2) { // 0, 1ë²ˆ êº¾ì„ì€ ì´ë¯¸ ê²€ì‚¬í–ˆìœ¼ë¯€ë¡œ ì œì™¸
                    if (board[y][x1] === 0 && board[y][x2] === 0) { // ë‘ ì½”ë„ˆê°€ ë¹„ì–´ìˆì–´ì•¼ í•¨
                        if (isLineClear(x1, y1, x1, y) && isLineClear(x1, y, x2, y) && isLineClear(x2, y, x2, y2)) {
                            return [{x: x1, y: y1}, {x: x1, y: y}, {x: x2, y: y}, {x: x2, y: y2}];
                        }
                    }
                }
            }

            // 2. ì¤‘ê°„ ì„ ë¶„ì´ ì„¸ë¡œì¶•(ìˆ˜ì§)ì¸ ê²½ìš° (ì¢Œ/ìš° í…Œë‘ë¦¬ ìš°íšŒ í¬í•¨)
            for (let x = 0; x <= cols + 1; x++) {
                if (x !== x1 && x !== x2) {
                    if (board[y1][x] === 0 && board[y2][x] === 0) { // ë‘ ì½”ë„ˆê°€ ë¹„ì–´ìˆì–´ì•¼ í•¨
                        if (isLineClear(x1, y1, x, y1) && isLineClear(x, y1, x, y2) && isLineClear(x, y2, x2, y2)) {
                            return [{x: x1, y: y1}, {x: x, y: y1}, {x: x, y: y2}, {x: x2, y: y2}];
                        }
                    }
                }
            }

            return null; // ì—°ê²° ë¶ˆê°€
        }

        function drawPath(pathPoints) {
            const pointsStr = pathPoints.map(p => {
                const cell = document.getElementById(`cell-${p.y}-${p.x}`);
                const cx = cell.offsetLeft + cell.offsetWidth / 2;
                const cy = cell.offsetTop + cell.offsetHeight / 2;
                return `${cx},${cy}`;
            }).join(' ');

            const newPolyline = pathLine.cloneNode(true);
            newPolyline.setAttribute('points', pointsStr);
            pathLine.parentNode.replaceChild(newPolyline, pathLine);
            
            pathLine = newPolyline;
        }

        // íƒ€ì´ë¨¸ ê´€ë ¨ í•¨ìˆ˜
        function timerTick() {
            timeRemaining--;
            updateTimerDisplay();
            
            if (timeRemaining <= 0) {
                clearInterval(timerInterval);
                isProcessing = true; // ê²Œì„ ì˜¤ë²„ ì‹œ í´ë¦­ ë°©ì§€
                messageOverlay.innerHTML = `
                    <h2 style="color: #ef4444;">íƒ€ì„ ì˜¤ë²„! â°</h2>
                    <p>ì‹œê°„ì´ ë‹¤ ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
                    <button onclick="startGame()" style="margin-top: 15px;">ë‹¤ì‹œ í•˜ê¸°</button>
                `;
                messageOverlay.classList.add('show');
            }
        }

        function updateTimerDisplay() {
            const timerDisplay = document.getElementById('timer-display');
            if (isTimeAttack) {
                timerDisplay.innerText = `ë‚¨ì€ ì‹œê°„: ${timeRemaining}ì´ˆ`;
                if (timeRemaining <= 10) {
                    timerDisplay.style.color = '#ef4444'; // 10ì´ˆ ì´í•˜ë©´ ë¹¨ê°„ìƒ‰ ê²½ê³ 
                } else {
                    timerDisplay.style.color = '';
                }
            }
        }
        
    </script>
</body>
</html>